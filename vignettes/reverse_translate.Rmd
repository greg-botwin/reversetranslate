---
title: "reverse_translate"
author: "Greg Botwin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ["vignette_citations.bib"]
link-citations: true
vignette: >
  %\VignetteIndexEntry{reverse_translate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(reversetranslate)
```
With the increase use of synthetic biology applications researchers might want to derive a DNA nucleotide sequence from a pre-specified amino acid sequence. This package is designed to assist you in such applications.

## Load Amino Acid Sequence(s) for Translation
The user must supply the amino acid sequence you want to reverse translate. The sequence must exist as a `character` vector and the individual amino acids must be written in a way that match the amino acids listed in your selected Codon Frequency Table. If you wish to reverse translate multiple amino acid seqeunces under the same conditions store them all in a single `list` and pass them to `reverse_translate` using one of the iterative functions described in more detail below. 

### Download Protein Amino Acid Sequence
An excellent source of protein amino acid sequences is the [UniProtKB/Swiss-Prot](https://www.uniprot.org/uniprot/?query=reviewed:yes). To reduce redundancy UniProtKB reports a cannonical sequence based on the following criteria:

1. It is the most prevalent.
2. It is the most similar to orthologous sequences found in other species.3.
3. By virtue of its length or amino acid composition, it allows the clearest description of domains, isoforms, polymorphisms, post-translational modifications, etc.
4. In the absence of any information, we choose the longest sequence.

Protein and nucleotide strings are often stored in a .FASTA file format. You can learn more aout FASTA format [here](http://genetics.bwh.harvard.edu/pph/FASTA.html). Below we will read in the amino acid sequence for the human protein Nucleotide-binding oligomerization domain-containing protein 2 (NOD2) using both base R and the very helpful Bioconductor Biostrings [@R-Biostrings] package.

```{r}
download.file(url = "https://www.uniprot.org/uniprot/Q9HC29.fasta", 
              destfile = "NOD2.FASTA")
```

### Read FASTA with Base R Functions
```{r}
nod2_txt <- utils::read.delim("NOD2.FASTA", comment.char = ">",
                       stringsAsFactors = FALSE, header = FALSE)

nod2_txt <- nod2_txt$V1 %>%
  paste0(collapse = "")

```

### Read FASTA Biostrings
```{r}
# Install Bioconductor Installer and Biostrings Pakcage if Needed
 if (!requireNamespace("BiocManager", quietly = TRUE)) {
       install.packages("BiocManager")
 }
 if (!requireNamespace("Biostrings", quietly = TRUE)) {
       BiocManager::install("Biostrings", version = "3.8")
 }
library(Biostrings)

# read with Biostrings
nod2_bs <- Biostrings::readAAStringSet("NOD2.FASTA")

```

## Codon Frequency Table
[@Athey2017]

### Format

### Supplied Codon Frequency Tables

### Building Your Own Codon Frequency Table 

## Reverse Translation
### Models of Translation
#### Proportional
```{r}
minimal_freq_tbl
```
For amino acid, assuming a proportional model, we would expect the proportion of AAA codons to be approximately equal the proportion of GGG codons and to be twice as large as the proportion of CCC codons. Let simulate to confirm. 
 
```{r, message=FALSE}
set.seed(1234)
codons <- replicate(100, {
  reverse_translate(amino_acid_seq = "X", codon_tbl = minimal_freq_tbl,
                    limit = 0, model = "proportional")
})

table(codons)
```

Lets See if This Holds True for an Amino Acid Sequence
```{r, message=FALSE}
codon_string <- replicate(100, {
  reverse_translate(amino_acid_seq = minimal_aa_seq, codon_tbl = minimal_freq_tbl,
                    limit = 0 , model = "proportional")
})

df <- dplyr::data_frame(codon_string = codon_string)
df %>%
  dplyr::mutate("AAA_count" = stringr::str_count(codon_string, "AAA")) %>%
  dplyr::mutate("TTT_count" = stringr::str_count(codon_string, "TTT")) %>%
  dplyr::mutate("GGG_count" = stringr::str_count(codon_string, "GGG")) %>%
  dplyr::mutate("CCC_count" = stringr::str_count(codon_string, "CCC")) %>%
  dplyr::summarise(mean_AAA = mean(AAA_count),
            mean_TTT = mean(TTT_count),
            mean_GGG = mean(GGG_count),
            mean_CCC = mean(CCC_count)
            )
```

#### Equal Model
```{r, message=FALSE}
set.seed(1234)
codons <- replicate(100, {
  reverse_translate(amino_acid_seq = "X", codon_tbl = minimal_freq_tbl,
                    limit = 0, model = "equal")
})

table(codons)
```

####  GC Biased
```{r}
nod2_txt
```

```{r, message=FALSE}
set.seed(1234)
nod2_nt_prop <- reverse_translate(amino_acid_seq = nod2_txt, codon_tbl = hsapien_tbl, limit = 0,
                  model = "proportional")


tokenizers::tokenize_characters(nod2_nt_prop, lowercase = FALSE) %>%
  table()


set.seed(1234)
nod2_nt_low_gc <- reverse_translate(amino_acid_seq = nod2_txt, codon_tbl = hsapien_tbl, limit = 0,
                  model = "gc_biased")

tokenizers::tokenize_characters(nod2_nt_low_gc, lowercase = FALSE) %>%
  table()
```
### Assigning a Codon Frequency Limit
### Running Reverse Translation on Multiple Amino Acid Sequences
#### Using `base::lapply`
#### Using `purrr:map`
#### Using the `futures` package and multiple cores


##  GC Biased
```{r}
nod2_txt
```

```{r, message=FALSE}
set.seed(1234)
nod2_nt_prop <- reverse_translate(amino_acid_seq = nod2_txt, codon_tbl = hsapien_tbl, limit = 0,
                  model = "proportional")


tokenizers::tokenize_characters(nod2_nt_prop, lowercase = FALSE) %>%
  table()


set.seed(1234)
nod2_nt_low_gc <- reverse_translate(amino_acid_seq = nod2_txt, codon_tbl = hsapien_tbl, limit = 0,
                  model = "gc_biased")

tokenizers::tokenize_characters(nod2_nt_low_gc, lowercase = FALSE) %>%
  table()
```

